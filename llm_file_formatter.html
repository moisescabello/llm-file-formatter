<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LLM File Formatter</title>
    <style>
        body {
            font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background-color: #f0f4f8;
            max-width: 800px;
            margin: 0 auto;
            padding: 40px 20px;
            color: #333;
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
        }

        #drop_zone {
            border: 3px dashed #3498db;
            border-radius: 20px;
            width: 100%;
            padding: 40px 20px;
            text-align: center;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            background-color: #ecf0f1;
            cursor: pointer;
        }

        #drop_zone:hover, #drop_zone.drag-over {
            background-color: #d6eaf8;
            transform: scale(1.02);
        }

        #drop_zone p {
            font-size: 18px;
            color: #7f8c8d;
        }

        #fileCounter {
            display: none;
            margin-top: 10px;
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border-radius: 20px;
            font-size: 14px;
            font-weight: bold;
        }

        #fileCounter.visible {
            display: inline-block;
        }

        #output {
            margin-top: 20px;
            padding: 20px;
            border: 1px solid #bdc3c7;
            border-radius: 10px;
            white-space: pre-wrap;
            font-family: 'Courier New', monospace;
            max-height: 400px;
            overflow-y: auto;
            background-color: #fff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .button {
            display: inline-block;
            flex: 1;
            margin: 20px 0;
            padding: 15px 20px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s ease;
            text-align: center;
        }

        .button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        #copyButton {
            background-color: #2ecc71;
        }

        #copyButton:hover {
            background-color: #27ae60;
        }

        #addFolderButton {
            background-color: #3498db;
        }

        #addFolderButton:hover {
            background-color: #2980b9;
        }

        #status {
            margin-top: 10px;
            margin-bottom: 10px;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            font-weight: bold;
            opacity: 0;
            max-height: 0;
            overflow: hidden;
            transition: opacity 0.3s ease, max-height 0.3s ease, margin 0.3s ease;
        }

        #status.show {
            max-height: 60px;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        .success {
            background-color: #d4edda;
            color: #155724;
        }

        .error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .warning {
            background-color: #fff3cd;
            color: #856404;
        }

        .file-tree {
            margin: 20px 0;
            background-color: white;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            padding: 10px;
            max-height: 350px;
            overflow-y: auto;
            display: none;
            font-size: 14px;
        }

        .tree-view {
            list-style: none;
            padding-left: 0;
            margin: 0;
        }

        .tree-view ul {
            list-style: none;
            padding-left: 16px;
            margin: 0;
        }

        .tree-item {
            padding: 3px 2px;
            border-radius: 4px;
            margin: 3px 0;
            display: flex;
            align-items: flex-start;
            flex-direction: column;
            width: 100%;
            box-sizing: border-box;
        }

        .tree-item:hover > .item-content {
            background-color: #f0f8ff;
        }

        .item-content {
            display: flex;
            align-items: center;
            width: 100%;
            min-height: 24px;
            border-radius: 4px;
            padding: 2px 0;
        }

        .tree-item label {
            margin-left: 4px;
            cursor: pointer;
            flex: 1;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-size: 13px;
            display: inline-block;
        }

        .folder-icon, .file-icon {
            margin-right: 4px;
            margin-left: 0;
            width: 16px;
            text-align: center;
            flex-shrink: 0;
            font-size: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .folder-icon {
            color: #3d85c6;
        }

        .file-icon {
            color: #696969;
        }

        .toggle-btn {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 10px;
            width: 14px;
            height: 14px;
            text-align: center;
            padding: 0;
            flex-shrink: 0;
            color: #999;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .checkbox-wrapper {
            margin: 0 4px 0 0;
            flex-shrink: 0;
        }

        .button-container {
            display: flex;
            justify-content: space-between;
            gap: 10px;
        }

        #clearButton {
            background-color: #e74c3c;
        }

        #clearButton:hover {
            background-color: #c0392b;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .pulse {
            animation: pulse 0.5s;
        }

        .metrics-separator {
            display: none;
            margin: 15px 0;
            height: 1px;
            background: linear-gradient(to right,
                transparent,
                rgba(107, 70, 193, 0.2) 20%,
                rgba(107, 70, 193, 0.4) 50%,
                rgba(107, 70, 193, 0.2) 80%,
                transparent);
            border: none;
        }

        /* Metrics panel styles */
        #metricsPanel {
            display: none;
            margin: 0 0 20px 0;
            padding: 20px;
            background: #6b46c1;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            color: white;
        }

        #metricsPanel.visible {
            display: block;
        }

        .metrics-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .metric-item {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 20px;
            backdrop-filter: blur(10px);
            font-size: 14px;
        }

        .metric-item strong {
            color: rgba(255, 255, 255, 0.9);
        }

        .metric-value {
            font-weight: bold;
            color: #fff;
            font-family: 'Courier New', monospace;
        }

        .progress-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 20px;
            margin-top: 15px;
        }

        .progress-item {
            text-align: center;
        }

        .progress-label {
            font-size: 12px;
            margin-bottom: 5px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .progress-percentage {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 8px;
        }

        .progress-bar {
            width: 100%;
            height: 24px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            overflow: hidden;
            position: relative;
            backdrop-filter: blur(10px);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-fill {
            height: 100%;
            border-radius: 12px;
            transition: width 0.5s ease, background 0.5s ease;
            position: relative;
            background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.4);
        }

        .progress-fill.warning {
            background: linear-gradient(90deg, #ff9800 0%, #f57c00 100%);
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.4);
        }

        .progress-fill.danger {
            background: linear-gradient(90deg, #f44336 0%, #d32f2f 100%);
            box-shadow: 0 2px 8px rgba(244, 67, 54, 0.4);
        }

        .progress-fill.animating::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.3) 50%,
                transparent 100%);
            animation: shimmer 0.8s ease-out;
        }

        @keyframes shimmer {
            0% {
                transform: translateX(-100%);
            }
            100% {
                transform: translateX(100%);
            }
        }
    </style>
</head>
<body>
    <h1>LLM File Formatter</h1>
    <div id="drop_zone">
        <p>Drag and drop files here</p>
        <span id="fileCounter" class="">0 files accumulated</span>
    </div>
    <div class="file-tree" id="fileTree">
        <div class="tree-view" id="treeView"></div>
    </div>
    <div class="button-container">
        <button id="addFolderButton" class="button">Add folder</button>
        <button id="copyButton" class="button">Copy to clipboard</button>
        <button id="clearButton" class="button">Clear All</button>
    </div>
    <label style="display:flex;align-items:center;gap:6px;margin-top:4px;font-size:14px;">
        <input type="checkbox" id="hideBinaryToggle"> Hide binaries
    </label>
    <label style="display:flex;align-items:center;gap:6px;margin-top:4px;font-size:14px;">
        <span>Encoding:</span>
        <select id="encodingSelect">
            <option value="utf-8" selected>UTF-8</option>
            <option value="windows-1252">ISO-8859-1 / Windows-1252</option>
        </select>
    </label>

    <!-- Elegant Separator -->
    <div class="metrics-separator"></div>

    <!-- Metrics Panel -->
    <div id="metricsPanel">
        <div class="metrics-header">
            <div class="metric-item">
                <strong>Size:</strong>
                <span class="metric-value" id="totalSize">0 KB</span>
            </div>
            <div class="metric-item">
                <strong>Tokens:</strong>
                <span class="metric-value" id="totalTokens">0</span>
            </div>
        </div>
        <div class="progress-grid">
            <div class="progress-item">
                <div class="progress-label">64K tokens</div>
                <div class="progress-percentage" id="percent64k">0%</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="bar64k"></div>
                </div>
            </div>
            <div class="progress-item">
                <div class="progress-label">128K tokens</div>
                <div class="progress-percentage" id="percent128k">0%</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="bar128k"></div>
                </div>
            </div>
            <div class="progress-item">
                <div class="progress-label">500K tokens</div>
                <div class="progress-percentage" id="percent500k">0%</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="bar500k"></div>
                </div>
            </div>
            <div class="progress-item">
                <div class="progress-label">1M tokens</div>
                <div class="progress-percentage" id="percent1m">0%</div>
                <div class="progress-bar">
                    <div class="progress-fill" id="bar1m"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="status"></div>
    <div id="output"></div>

    <script>
        let selectionOrder = [];

        // Configurable limits to control memory usage
        const FILE_LIMITS = {
            MAX_FILE_SIZE: 10 * 1024 * 1024, // 10MB per file
            MAX_CONTENT_LENGTH: 200_000, // Max characters per content
            MAX_FILES: 100, // Max files per operation
            MAX_TOTAL_SIZE: 50 * 1024 * 1024 // 50MB total
        };

        // Index files by path to avoid storing contents in memory
        let fileMap = new Map();
        let currentFolderFiles = [];

        // Accumulated files from drag & drop operations
        let accumulatedFiles = new Map(); // Key: unique identifier, Value: file object

        // File content cache to avoid duplicate reads with size limit
        const fileContentCache = new Map(); // Key: file ID, Value: content
        const MAX_CACHE_SIZE = 50; // Maximum number of files to keep in cache

        // Token limits for different models
        const TOKEN_LIMITS = {
            '64k': 64000,
            '128k': 128000,
            '500k': 500000,
            '1m': 1000000
        };

        // Helper function to process a single file and return its metrics
        async function processFileMetrics(file) {
            if (file.size > FILE_LIMITS.MAX_FILE_SIZE) {
                return { bytes: 0, characters: 0, error: false };
            }

            const bytes = file.size;
            let characters = 0;
            let error = false;

            try {
                const content = await readFileCached(file);
                characters = content.length;
            } catch (err) {
                console.error(`Error reading file ${file.name}:`, err);
                error = true;
                // Estimate characters based on file size if read fails
                // Rough approximation: 1 byte ≈ 1 character for text files
                characters = Math.min(file.size, FILE_LIMITS.MAX_CONTENT_LENGTH);
            }

            return { bytes, characters, error };
        }

        // Calculate metrics for all accumulated and selected files
        async function calculateMetrics() {
            let totalBytes = 0;
            let totalCharacters = 0;
            let errorCount = 0;
            const seen = new Set();

            // Process accumulated files from drag & drop (deduplicated)
            for (const [fileId, file] of accumulatedFiles) {
                const did = getDedupId(file);
                if (seen.has(did)) continue;
                seen.add(did);
                const result = await processFileMetrics(file);
                totalBytes += result.bytes;
                totalCharacters += result.characters;
                if (result.error) errorCount++;
            }

            // Process selected files from folder tree (deduplicated across both sources)
            for (const filePath of selectionOrder) {
                const file = fileMap.get(filePath);
                if (!file || !isTextFile(file)) continue;

                const did = getDedupId(file);
                if (seen.has(did)) continue;
                seen.add(did);
                const result = await processFileMetrics(file);
                totalBytes += result.bytes;
                totalCharacters += result.characters;
                if (result.error) errorCount++;
            }

            // Show error summary if there were errors
            if (errorCount > 0) {
                console.warn(`Failed to read ${errorCount} file(s). Token count is estimated.`);
            }

            // Estimate tokens (rough approximation: 1 token ≈ 4 characters)
            const estimatedTokens = Math.ceil(totalCharacters / 4);

            return {
                bytes: totalBytes,
                characters: totalCharacters,
                tokens: estimatedTokens,
                errors: errorCount
            };
        }

        // Update the metrics panel UI
        async function updateMetricsPanel() {
            const panel = document.getElementById('metricsPanel');
            const separator = document.querySelector('.metrics-separator');

            // Check if we have any files
            const hasFiles = accumulatedFiles.size > 0 || selectionOrder.length > 0;

            if (!hasFiles) {
                panel.classList.remove('visible');
                if (separator) separator.style.display = 'none';
                return;
            }

            // Calculate metrics
            const metrics = await calculateMetrics();

            // Show panel and separator
            panel.classList.add('visible');
            if (separator) separator.style.display = 'block';

            // Update size
            const sizeKB = (metrics.bytes / 1024).toFixed(1);
            document.getElementById('totalSize').textContent = `${sizeKB} KB`;

            // Update tokens
            const tokenDisplay = metrics.tokens >= 1000
                ? `~${(metrics.tokens / 1000).toFixed(1)}K`
                : `~${metrics.tokens}`;
            document.getElementById('totalTokens').textContent = tokenDisplay;

            // Update progress bars
            updateProgressBar('64k', metrics.tokens, TOKEN_LIMITS['64k']);
            updateProgressBar('128k', metrics.tokens, TOKEN_LIMITS['128k']);
            updateProgressBar('500k', metrics.tokens, TOKEN_LIMITS['500k']);
            updateProgressBar('1m', metrics.tokens, TOKEN_LIMITS['1m']);
        }

        // Track previous percentages to detect changes
        let previousPercentages = {
            '64k': 0,
            '128k': 0,
            '500k': 0,
            '1m': 0
        };

        // Track if a bar has already animated once
        let animatedOnce = new Set();

        // Debounce timer for metrics updates
        let metricsUpdateTimer = null;

        // Debounced version of updateMetricsPanel to avoid excessive updates
        async function updateMetricsPanelDebounced() {
            // Clear any existing timer
            if (metricsUpdateTimer) {
                clearTimeout(metricsUpdateTimer);
            }

            // Set a new timer to update after 300ms of inactivity
            metricsUpdateTimer = setTimeout(async () => {
                await updateMetricsPanel();
            }, 300);
        }

        // Update individual progress bar
        function updateProgressBar(limitKey, currentTokens, maxTokens) {
            const percentage = Math.min(100, (currentTokens / maxTokens) * 100);
            const percentageText = percentage.toFixed(1) + '%';

            // Update percentage text (defensive: element may be missing)
            const percentEl = document.getElementById(`percent${limitKey}`);
            if (percentEl) percentEl.textContent = percentageText;

            // Update bar width
            const bar = document.getElementById(`bar${limitKey}`);
            if (!bar) {
                previousPercentages[limitKey] = percentage;
                return;
            }

            // Check if this is the first growth from 0 for this bar, then animate once
            const prevPercentage = previousPercentages[limitKey] || 0;
            if (percentage > 0 && prevPercentage === 0 && !animatedOnce.has(limitKey)) {
                bar.classList.add('animating');
                setTimeout(() => {
                    bar.classList.remove('animating');
                }, 800); // Match animation duration
                animatedOnce.add(limitKey);
            }

            bar.style.width = percentage + '%';
            previousPercentages[limitKey] = percentage;

            // Update bar color based on percentage
            bar.classList.remove('warning', 'danger');
            if (percentage >= 90) {
                bar.classList.add('danger');
            } else if (percentage >= 70) {
                bar.classList.add('warning');
            }
        }

        // Update file counter display
        function updateFileCounter() {
            const counter = document.getElementById('fileCounter');
            if (!counter) return;

            const count = accumulatedFiles.size;
            if (count > 0) {
                counter.textContent = `${count} file${count !== 1 ? 's' : ''} accumulated`;
                counter.classList.add('visible');
            } else {
                counter.classList.remove('visible');
            }
        }

        // Note: removed unused loading state to simplify logic

        // Determine if a file should be treated as text
        function isTextFile(file) {
            // If the browser provides a textual MIME type, use it
            if (file && typeof file.type === 'string' && file.type.startsWith('text/')) {
                return true;
            }

            // Whitelist of common text extensions
            const textExtensions = new Set([
                'txt','md','markdown','js','mjs','cjs','ts','tsx','jsx','html','htm','css','svg',
                'json','jsonc','xml','csv','py','java','kt','kts','swift','c','h','cpp','cc','hh','hpp','rs',
                'go','rb','php','pl','r','sql','sh','bash','zsh','fish','ps1','yml','yaml','toml','ini','cfg','conf','log',
                'gradle','properties','env','dockerfile','makefile','mk','cmake','nuspec','cs','vb','scala','lua'
            ]);

            const name = file && file.name ? file.name : '';
            const parts = name.split('.');
            const ext = parts.length > 1 ? parts.pop().toLowerCase() : '';

            // Consider some extensionless names as text (e.g., LICENSE, Makefile)
            const textNames = new Set(['license', 'licence', 'copying', 'readme', 'changelog', 'makefile', 'dockerfile']);
            if (!ext && textNames.has(name.toLowerCase())) return true;

            return textExtensions.has(ext);
        }

        // Basic validation of file count and total size
        // Returns true if valid, false if invalid
        // When warnOnly=true, shows warning but doesn't block operation
        function validateFiles(files, warnOnly = false) {
            const count = files.length;
            let hasCountError = false;
            let hasSizeError = false;

            if (count > FILE_LIMITS.MAX_FILES) {
                const message = warnOnly
                    ? `Warning: Too many files (max ${FILE_LIMITS.MAX_FILES}). Some files may be skipped.`
                    : `Error: Cannot process ${count} files. Maximum is ${FILE_LIMITS.MAX_FILES} files.`;
                showStatus(message, warnOnly ? 'warning' : 'error');
                hasCountError = true;
            }

            let totalSize = 0;
            for (const f of files) totalSize += f.size || 0;
            if (totalSize > FILE_LIMITS.MAX_TOTAL_SIZE) {
                const lim = (FILE_LIMITS.MAX_TOTAL_SIZE / 1024 / 1024).toFixed(0);
                const message = warnOnly
                    ? `Warning: Total size exceeds limit (${lim}MB). Some files may be skipped.`
                    : `Error: Total size (${(totalSize / 1024 / 1024).toFixed(0)}MB) exceeds ${lim}MB limit.`;
                showStatus(message, warnOnly ? 'warning' : 'error');
                hasSizeError = true;
            }

            // Return false if any validation failed
            return !(hasCountError || hasSizeError);
        }

        // Sanitize the language tag for the code fence
        function sanitizeLangTag(tag) {
            const t = (tag || '').toString().toLowerCase();
            return /^[a-z0-9+\-]+$/.test(t) ? t : '';
        }

        const LANG_MAP = {
            js: 'javascript', mjs: 'javascript', cjs: 'javascript',
            ts: 'typescript', tsx: 'tsx', jsx: 'jsx',
            py: 'python', rb: 'ruby',
            sh: 'bash', bash: 'bash', zsh: 'bash', fish: 'bash', env: 'bash',
            ps1: 'powershell',
            yml: 'yaml', yaml: 'yaml',
            html: 'html', htm: 'html',
            kt: 'kotlin', kts: 'kotlin',
            rs: 'rust',
            c: 'c', h: 'c',
            cpp: 'cpp', cc: 'cpp', cxx: 'cpp', hpp: 'cpp', hh: 'cpp',
            cs: 'csharp',
            md: 'markdown', markdown: 'markdown',
            toml: 'toml',
            ini: 'ini', cfg: 'ini', conf: 'ini', properties: 'ini',
            gradle: 'groovy',
            dockerfile: 'dockerfile', makefile: 'makefile', mk: 'makefile', cmake: 'cmake',
            xml: 'xml', nuspec: 'xml',
            jsonc: 'json'
        };
        function mapLangTag(ext) {
            const t = sanitizeLangTag(ext);
            return LANG_MAP[t] || t;
        }

        // Generate unique identifier for a file
        function getFileId(file) {
            // Use path (when available), size, and lastModified to create a more unique ID
            const pathPart = file && (file.webkitRelativePath || file.name) ? (file.webkitRelativePath || file.name) : '';
            return `${pathPart}-${file.size}-${file.lastModified}`;
        }

        // Generate a more robust unique ID for DOM elements
        function generateUniqueElementId(path, prefix = 'cb') {
            // Use a better hash function to reduce collisions
            let hash = 0;
            const str = path || '';
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash; // Convert to 32-bit integer
            }
            // Add timestamp component to ensure uniqueness
            const timestamp = Date.now().toString(36).slice(-4);
            // Add random component for extra safety
            const random = Math.random().toString(36).slice(-4);
            // Convert to base36 and combine components
            return `${prefix}-${Math.abs(hash).toString(36)}-${timestamp}-${random}`;
        }

        // Generate a deduplication ID that is stable across sources (drop vs folder)
        // Uses name, size, lastModified and type; intentionally ignores path
        function getDedupId(file) {
            const name = file && file.name ? file.name : '';
            const size = file && typeof file.size === 'number' ? file.size : 0;
            const lm = file && typeof file.lastModified === 'number' ? file.lastModified : 0;
            const type = file && file.type ? file.type : '';
            return `${name}::${size}::${lm}::${type}`;
        }

        // Aggregate current files (accumulated + selected) into a deduplicated set
        function aggregateCurrentFilesDedup() {
            const idsSet = new Set();
            let totalSize = 0;

            // Accumulated (drag & drop)
            for (const f of accumulatedFiles.values()) {
                if (!f) continue;
                const id = getDedupId(f);
                if (!idsSet.has(id)) {
                    idsSet.add(id);
                    totalSize += f.size || 0;
                }
            }

            // Selected from folder
            for (const p of selectionOrder) {
                const f = fileMap.get(p);
                if (!f || !isTextFile(f)) continue;
                const id = getDedupId(f);
                if (!idsSet.has(id)) {
                    idsSet.add(id);
                    totalSize += f.size || 0;
                }
            }

            return { idsSet, count: idsSet.size, size: totalSize };
        }

        // Read file with caching to avoid duplicate reads
        async function readFileCached(file) {
            const encodingSelect = document.getElementById('encodingSelect');
            const selectedEncoding = encodingSelect && encodingSelect.value ? encodingSelect.value : 'utf-8';
            const fileId = getFileId(file) + '-' + selectedEncoding;

            // Check cache first (including cached errors)
            if (fileContentCache.has(fileId)) {
                const cached = fileContentCache.get(fileId);
                // Touch entry to approximate LRU behavior
                fileContentCache.delete(fileId);
                fileContentCache.set(fileId, cached);
                // If it's a cached error, throw it again
                if (cached instanceof Error) {
                    throw cached;
                }
                return cached;
            }

            // Read file and cache the result with size limit
            try {
                const content = await readFileAsText(file);

                // Implement cache size limit - remove oldest entry if at limit
                if (fileContentCache.size >= MAX_CACHE_SIZE) {
                    const firstKey = fileContentCache.keys().next().value;
                    fileContentCache.delete(firstKey);
                }

                fileContentCache.set(fileId, content);
                return content;
            } catch (err) {
                console.error(`Error reading file ${file.name}:`, err);
                // Cache the error to avoid repeated failed attempts
                if (fileContentCache.size >= MAX_CACHE_SIZE) {
                    const firstKey = fileContentCache.keys().next().value;
                    fileContentCache.delete(firstKey);
                }
                fileContentCache.set(fileId, err);
                throw err;
            }
        }

        // Render all accumulated and selected files
        async function renderAllFiles() {
            const output = document.getElementById('output');
            output.innerHTML = '';

            const hasAccumulatedFiles = accumulatedFiles.size > 0;
            const hasSelectedFiles = selectionOrder.length > 0;

            if (!hasAccumulatedFiles && !hasSelectedFiles) {
                return;
            }

            const results = [];
            let omittedLarge = 0;
            let totalFiles = 0;
            let errorFiles = 0;
            const seen = new Set();

            // Process accumulated files from drag & drop
            for (const [fileId, file] of accumulatedFiles) {
                const did = getDedupId(file);
                if (seen.has(did)) continue;
                if (file.size > FILE_LIMITS.MAX_FILE_SIZE) {
                    console.warn(`Skipped very large file: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                    omittedLarge++;
                    continue;
                }

                try {
                    const contentRaw = await readFileCached(file);
                    let content = contentRaw || '';
                    if (content.length > FILE_LIMITS.MAX_CONTENT_LENGTH) {
                        content = content.substring(0, FILE_LIMITS.MAX_CONTENT_LENGTH) + '\n[... content truncated ...]';
                    }
                    // Escape HTML content to prevent injection
                    content = escapeHtml(content);

                    const parts = file.name.split('.');
                    const extRaw = parts.length > 1 ? parts.pop().toLowerCase() : '';
                    const fileExtension = mapLangTag(extRaw);
                    const fence = getSafeFence(content);
                    const safeName = escapeHtml(file.name);
                    results.push('Filename: ' + safeName + '\n' + fence + fileExtension + '\n' + content + '\n' + fence + '\n\n');
                    totalFiles++;
                    seen.add(did);
                } catch (err) {
                    console.error(`Error reading file ${file.name}:`, err);
                    errorFiles++;
                    // Add placeholder for errored file
                    const safeName = escapeHtml(file.name);
                    results.push('Filename: ' + safeName + '\n```\n[Error reading file: ' + escapeHtml(err.message) + ']\n```\n\n');
                    seen.add(did);
                }
            }

            // Process selected files from folder tree
            for (const filePath of selectionOrder) {
                const file = fileMap.get(filePath);
                if (!file || !isTextFile(file)) continue;
                const did = getDedupId(file);
                if (seen.has(did)) continue;

                if (file.size > FILE_LIMITS.MAX_FILE_SIZE) {
                    console.warn(`Skipped very large file: ${file.name} (${(file.size / 1024 / 1024).toFixed(2)}MB)`);
                    omittedLarge++;
                    continue;
                }

                try {
                    const contentRaw = await readFileCached(file);
                    let content = contentRaw || '';
                    if (content.length > FILE_LIMITS.MAX_CONTENT_LENGTH) {
                        content = content.substring(0, FILE_LIMITS.MAX_CONTENT_LENGTH) + '\n[... content truncated ...]';
                    }
                    // Escape HTML content to prevent injection
                    content = escapeHtml(content);

                    const parts = file.name.split('.');
                    const extRaw = parts.length > 1 ? parts.pop().toLowerCase() : '';
                    const fileExtension = mapLangTag(extRaw);
                    const fence = getSafeFence(content);
                    const safeName = escapeHtml(file.name);
                    results.push('Filename: ' + safeName + '\n' + fence + fileExtension + '\n' + content + '\n' + fence + '\n\n');
                    totalFiles++;
                    seen.add(did);
                } catch (err) {
                    console.error(`Error reading file ${file.name}:`, err);
                    errorFiles++;
                    // Add placeholder for errored file
                    const safeName = escapeHtml(file.name);
                    results.push('Filename: ' + safeName + '\n```\n[Error reading file: ' + escapeHtml(err.message) + ']\n```\n\n');
                    seen.add(did);
                }
            }

            output.innerHTML = results.join('');

            // Build status message with all relevant information
            let msg = `${totalFiles} file${totalFiles !== 1 ? 's' : ''} ready.`;
            if (omittedLarge > 0 || errorFiles > 0) {
                const issues = [];
                if (omittedLarge > 0) issues.push(`${omittedLarge} large`);
                if (errorFiles > 0) issues.push(`${errorFiles} with errors`);
                msg += ` Skipped: ${issues.join(', ')}.`;
            }
            msg += ' Click "Copy".';

            showStatus(msg, errorFiles > 0 ? 'error' : 'success');

            // Update metrics panel (debounced)
            updateMetricsPanelDebounced();
        }

        // Clear all accumulated files
        function clearAll() {
            // Clear accumulated files from drag & drop
            accumulatedFiles.clear();

            // Clear file content cache
            fileContentCache.clear();

            // Clear folder selection
            selectionOrder = [];
            fileMap.clear();
            currentFolderFiles = [];

            // Clear debounce timer to prevent memory leak
            if (metricsUpdateTimer) {
                clearTimeout(metricsUpdateTimer);
                metricsUpdateTimer = null;
            }

            // Clear UI
            const output = document.getElementById('output');
            output.innerHTML = '';

            const fileTree = document.getElementById('fileTree');
            fileTree.style.display = 'none';

            const treeView = document.getElementById('treeView');
            treeView.innerHTML = '';

            // Update file counter
            updateFileCounter();

            // Hide metrics panel and separator
            const panel = document.getElementById('metricsPanel');
            const separator = document.querySelector('.metrics-separator');
            panel.classList.remove('visible');
            if (separator) separator.style.display = 'none';

            // Reset previous percentages
            previousPercentages = {
                '64k': 0,
                '128k': 0,
                '500k': 0,
                '1m': 0
            };

            // Reset one-time animation flags
            animatedOnce = new Set();

            showStatus('All files cleared', 'success');
        }

        async function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            // Clear drag visual state
            const dz = document.getElementById('drop_zone');
            dz.classList.remove('drag-over');

            // Convert to array and filter text files
            const allFiles = Array.from(e.dataTransfer.files || []);
            const textFiles = allFiles.filter(isTextFile);

            const skippedBinary = allFiles.length - textFiles.length;

            if (textFiles.length === 0) {
                if (skippedBinary > 0) {
                    showStatus(`Skipped ${skippedBinary} non-text file(s)`, 'error');
                }
                return;
            }

            // Deduplicated checks across accumulated + selected + new
            const { idsSet: existingIds, count: currentCount, size: currentSize } = aggregateCurrentFilesDedup();
            const tmpIds = new Set(existingIds);
            let newUniqueCount = 0;
            let newUniqueSize = 0;
            for (const f of textFiles) {
                const id = getDedupId(f);
                if (!tmpIds.has(id)) {
                    tmpIds.add(id);
                    newUniqueCount++;
                    newUniqueSize += f.size || 0;
                }
            }
            const potentialTotal = currentCount + newUniqueCount;
            if (potentialTotal > FILE_LIMITS.MAX_FILES) {
                showStatus(`Cannot add files. Would exceed limit of ${FILE_LIMITS.MAX_FILES} files.`, 'error');
                return;
            }
            const potentialTotalSize = currentSize + newUniqueSize;
            if (potentialTotalSize > FILE_LIMITS.MAX_TOTAL_SIZE) {
                const lim = (FILE_LIMITS.MAX_TOTAL_SIZE / 1024 / 1024).toFixed(0);
                showStatus(`Cannot add files. Total size would exceed ${lim}MB limit.`, 'error');
                return;
            }

            // Add files to accumulated collection
            let addedCount = 0;
            let duplicateCount = 0;

            for (const file of textFiles) {
                const fileId = getFileId(file);
                if (accumulatedFiles.has(fileId)) {
                    duplicateCount++;
                } else {
                    accumulatedFiles.set(fileId, file);
                    addedCount++;
                }
            }

            // Render all accumulated files
            await renderAllFiles();

            // Update file counter display
            updateFileCounter();

            // Metrics panel updated by renderAllFiles via debounce

            // Show status message
            let statusMsg = '';
            if (addedCount > 0 && duplicateCount > 0 && skippedBinary > 0) {
                statusMsg = `Added ${addedCount} file(s). ${duplicateCount} duplicate(s) and ${skippedBinary} binary file(s) skipped. Total: ${accumulatedFiles.size}`;
            } else if (addedCount > 0 && duplicateCount > 0) {
                statusMsg = `Added ${addedCount} file(s). ${duplicateCount} duplicate(s) skipped. Total: ${accumulatedFiles.size}`;
            } else if (addedCount > 0 && skippedBinary > 0) {
                statusMsg = `Added ${addedCount} file(s). ${skippedBinary} binary file(s) skipped. Total: ${accumulatedFiles.size}`;
            } else if (addedCount > 0) {
                statusMsg = `Added ${addedCount} file(s). Total: ${accumulatedFiles.size}`;
            } else if (duplicateCount > 0) {
                statusMsg = `${duplicateCount} duplicate file(s) skipped. Total: ${accumulatedFiles.size}`;
            }

            showStatus(statusMsg, 'success');
        }

        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            document.getElementById('drop_zone').classList.add('drag-over');
        }

        function handleDragLeave(e) {
            // Only remove style if we're actually leaving the drop zone, not entering a child element
            const dropZone = document.getElementById('drop_zone');
            const rect = dropZone.getBoundingClientRect();
            const x = e.clientX;
            const y = e.clientY;

            // Check if the mouse is outside the drop zone boundaries
            if (x < rect.left || x >= rect.right || y < rect.top || y >= rect.bottom) {
                dropZone.classList.remove('drag-over');
            }
        }

        async function copyToClipboard() {
            const output = document.getElementById('output');
            let textToCopy = '';

            // Check if we have files to copy
            const hasFiles = accumulatedFiles.size > 0 || selectionOrder.length > 0;

            if (hasFiles) {
                // If output is already populated, use it directly to avoid re-reading files
                const currentOutput = output.innerText || output.textContent || '';
                if (currentOutput.trim()) {
                    textToCopy = currentOutput;
                } else {
                    // Output is empty, need to render first
                    await renderAllFiles();
                    textToCopy = output.innerText || output.textContent || '';
                }
            } else {
                // No files selected, copy whatever is in output
                textToCopy = output.innerText || output.textContent || '';
            }

            // Guard: do not copy empty content
            if (!textToCopy || !textToCopy.trim()) {
                showStatus('No content to copy', 'error');
                return;
            }

            try {
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    await navigator.clipboard.writeText(textToCopy);
                } else {
                    // Safe fallback
                    const ok = fallbackCopyText(textToCopy);
                    if (!ok) throw new Error('Fallback copy failed');
                }
                showStatus('Content copied to clipboard!', 'success');
            } catch (err) {
                console.error('Error copying with modern API:', err);
                // Try fallback if it fails
                const ok = fallbackCopyText(textToCopy);
                if (!ok) {
                    showStatus('Error copying to clipboard', 'error');
                }
            }
        }

        function fallbackCopyText(text) {
            try {
                const ta = document.createElement('textarea');
                ta.value = text;
                ta.setAttribute('readonly', '');
                ta.style.position = 'fixed';
                ta.style.top = '-1000px';
                document.body.appendChild(ta);
                ta.focus();
                ta.select();
                const ok = document.execCommand('copy');
                document.body.removeChild(ta);
                return ok;
            } catch (_) {
                return false;
            }
        }

        function escapeHtml(unsafe) {
            const s = unsafe == null ? '' : String(unsafe);
            return s
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;")
                 .replace(/`/g, "&#96;");
        }

        // Generate a safe backtick fence to wrap content that may include backticks
        function getSafeFence(text) {
            const matches = (typeof text === 'string' ? text : '').match(/`+/g);
            let maxRun = 0;
            if (matches) {
                for (const m of matches) {
                    if (m.length > maxRun) maxRun = m.length;
                }
            }
            const count = Math.max(3, maxRun + 1);
            return '`'.repeat(count);
        }

        function showStatus(message, type) {
            let status = document.getElementById('status');
            status.textContent = message;
            status.className = type + ' show';
            status.style.opacity = '1';

            let dropZone = document.getElementById('drop_zone');
            dropZone.classList.add('pulse');

            setTimeout(() => {
                status.style.opacity = '0';
                status.classList.remove('show');
                dropZone.classList.remove('pulse');
            }, 2000);
        }

        // New function to select folder
        function selectFolder() {
            // Create an invisible file input
            const input = document.createElement('input');
            input.type = 'file';
            input.webkitdirectory = true;
            input.multiple = true;
            
            input.onchange = function(e) {
                const fileTree = document.getElementById('fileTree');
                fileTree.style.display = 'block';
                fileTree.style.height = 'auto';
                fileTree.style.minHeight = '200px';
                
                const files = Array.from(e.target.files);
                const textFiles = files.filter(isTextFile);

                // Warn only; enforce limits on actual checkbox selection
                validateFiles(textFiles, true);

                // Clear previous references completely to prevent memory leaks
                selectionOrder = [];

                // Clear the map entries before creating new one
                if (fileMap) {
                    fileMap.clear();
                }
                fileMap = new Map();

                // Clear previous folder files array
                currentFolderFiles = [];
                currentFolderFiles = files;

                // Create tree structure
                const tree = buildFileTree(getFilteredFolderFiles());
                renderFileTree(tree);

                // Index files by path for on-demand reading
                for (const file of files) {
                    const path = '/' + (file.webkitRelativePath || file.name);
                    fileMap.set(path, file);
                }

                // loading state removed (no-op)
                showStatus('Folder loaded. Select files and click "Copy".', 'success');
            };
            
            input.click();
        }
        
        function getFilteredFolderFiles() {
            const hb = document.getElementById('hideBinaryToggle');
            const list = currentFolderFiles || [];
            return hb && hb.checked ? list.filter(isTextFile) : list;
        }
        
        // Build the tree structure from files
        function buildFileTree(files) {
            const root = { children: {}, isFolder: true, name: 'root', path: '/' };
            
            files.forEach(file => {
                // Build the relative path (fallback if webkitRelativePath is missing)
                const path = file.webkitRelativePath || file.name;
                const parts = path.split('/');
                
                let current = root;
                let currentPath = '';
                
                // Traverse/build the tree structure
                for (let i = 0; i < parts.length; i++) {
                    const part = parts[i];
                    currentPath += (currentPath ? '/' : '') + part;
                    
                    if (i === parts.length - 1) {
                        // It's a file
                        current.children[part] = {
                            isFolder: false,
                            name: part,
                            path: '/' + currentPath,
                            file: file
                        };
                    } else {
                        // It's a folder
                        if (!current.children[part]) {
                            current.children[part] = {
                                children: {},
                                isFolder: true,
                                name: part,
                                path: '/' + currentPath
                            };
                        }
                        current = current.children[part];
                    }
                }
            });
            
            return root;
        }

        // Update a folder LI checkbox based on the state of its descendant checkboxes
        function updateFolderCheckboxState(folderLi) {
            if (!folderLi) return;
            const folderCb = folderLi.querySelector('input[type="checkbox"][data-is-folder="true"]');
            if (!folderCb) return;

            const childCbs = Array.from(folderLi.querySelectorAll('input[type="checkbox"]'))
                .filter(cb => cb !== folderCb && !cb.disabled);

            if (childCbs.length === 0) {
                folderCb.indeterminate = false;
                folderCb.checked = false;
                return;
            }

            const checkedCount = childCbs.filter(cb => cb.checked).length;
            if (checkedCount === 0) {
                folderCb.indeterminate = false;
                folderCb.checked = false;
            } else if (checkedCount === childCbs.length) {
                folderCb.indeterminate = false;
                folderCb.checked = true;
            } else {
                folderCb.indeterminate = true;
                folderCb.checked = false;
            }
        }

        // Walk up and update all ancestor folders' tri-state after a change
        function updateAncestorFolders(startLi) {
            let current = startLi;
            while (current) {
                const parentLi = current.parentElement ? current.parentElement.closest('li.tree-item[data-is-folder="true"]') : null;
                if (!parentLi) break;
                updateFolderCheckboxState(parentLi);
                current = parentLi;
            }
        }
        
        // Render the file tree in the DOM
        function renderFileTree(node, parentElement = null) {
            const container = parentElement || document.getElementById('treeView');
            const ul = document.createElement('ul');
            ul.style.display = 'block';
            ul.style.width = '100%';
            
            if (!parentElement) {
                container.innerHTML = '';
                container.appendChild(ul);
            } else {
                parentElement.appendChild(ul);
            }
            
            // Sort: folders first, then files
            const items = Object.values(node.children);
            items.sort((a, b) => {
                if (a.isFolder && !b.isFolder) return -1;
                if (!a.isFolder && b.isFolder) return 1;
                return a.name.localeCompare(b.name);
            });
            
            items.forEach(item => {
                const li = document.createElement('li');
                li.className = 'tree-item';
                li.dataset.path = item.path;
                li.dataset.isFolder = item.isFolder ? 'true' : 'false';
                
                // Container for item content (icon, checkbox, label)
                const itemContent = document.createElement('div');
                itemContent.className = 'item-content';
                
                if (item.isFolder) {
                    // Folder
                    const toggleBtn = document.createElement('button');
                    toggleBtn.className = 'toggle-btn';
                    toggleBtn.innerHTML = '<small>▼</small>';
                    toggleBtn.onclick = function(e) {
                        e.stopPropagation();
                        const sublist = li.querySelector('ul');
                        if (sublist) {
                            const isVisible = sublist.style.display !== 'none';
                            sublist.style.display = isVisible ? 'none' : 'block';
                            toggleBtn.innerHTML = isVisible ? '<small>►</small>' : '<small>▼</small>';
                        }
                    };
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'checkbox-wrapper';
                    checkbox.dataset.path = item.path;
                    checkbox.dataset.isFolder = 'true';
                    // Use robust hash function for unique IDs
                    const folderCbId = generateUniqueElementId(item.path, 'cb-folder');
                    checkbox.id = folderCbId;
                    checkbox.onchange = async function() {
                        // Check/uncheck all child items (only enabled)
                        const checkboxes = li.querySelectorAll('input[type="checkbox"]');
                        checkboxes.forEach(cb => {
                            if (cb !== checkbox && !cb.disabled) {
                                cb.checked = checkbox.checked;
                                updateSelection(cb, true); // Skip individual metrics updates
                            }
                        });
                        updateSelection(checkbox, true); // Skip individual metrics update

                        // Update metrics with debounce for better performance
                        updateMetricsPanelDebounced();
                        // Update tri-state on this folder and ancestors
                        updateFolderCheckboxState(li);
                        updateAncestorFolders(li);
                    };
                    
                    const folderIcon = document.createElement('span');
                    folderIcon.className = 'folder-icon';
                    folderIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>';
                    
                    const label = document.createElement('label');
                    label.textContent = item.name;
                    label.htmlFor = folderCbId;
                    
                    // Add all elements to the content container
                    itemContent.appendChild(toggleBtn);
                    itemContent.appendChild(checkbox);
                    itemContent.appendChild(folderIcon);
                    itemContent.appendChild(label);
                    
                    // Add the content container to the li element
                    li.appendChild(itemContent);
                    ul.appendChild(li);
                    
                    // If the folder has children, render them
                    if (Object.keys(item.children).length > 0) {
                        renderFileTree(item, li);
                    }
                    // Initialize tri-state based on children
                    updateFolderCheckboxState(li);
                } else {
                    // File
                    const spacer = document.createElement('span');
                    spacer.className = 'toggle-btn';
                    spacer.style.visibility = 'hidden';
                    
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.className = 'checkbox-wrapper';
                    checkbox.dataset.path = item.path;
                    checkbox.dataset.isFolder = 'false';
                    // Use robust hash function for unique IDs
                    const fileCbId = generateUniqueElementId(item.path, 'cb-file');
                    checkbox.id = fileCbId;
                    const isText = isTextFile(item.file);
                    checkbox.disabled = !isText;
                    checkbox.checked = isText && selectionOrder.includes(item.path);
                    checkbox.onchange = async function() {
                        updateSelection(checkbox, true); // Skip metrics update in updateSelection
                        // Update metrics with debounce for better performance
                        updateMetricsPanelDebounced();
                        // Update parent folder tri-state
                        updateAncestorFolders(li);
                    };
                    
                    const fileIcon = document.createElement('span');
                    fileIcon.className = 'file-icon';
                    
                    // Determine file type to show an appropriate icon
                    const fileExt = item.name.split('.').pop().toLowerCase();
                    if (['md', 'txt', 'doc', 'docx'].includes(fileExt)) {
                        fileIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>';
                    } else if (['jpg', 'jpeg', 'png', 'gif', 'svg'].includes(fileExt)) {
                        fileIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>';
                    } else if (['js', 'ts', 'html', 'css', 'py', 'java', 'cpp'].includes(fileExt)) {
                        fileIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>';
                    } else {
                        fileIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>';
                    }
                    
                    const label = document.createElement('label');
                    label.textContent = item.name;
                    label.htmlFor = fileCbId;
                    if (!isText) {
                        label.title = 'Non-text file (not selectable)';
                        label.style.opacity = '0.6';
                        label.setAttribute('aria-disabled', 'true');
                    }
                    
                    // Add all elements to the content container
                    itemContent.appendChild(spacer);
                    itemContent.appendChild(checkbox);
                    itemContent.appendChild(fileIcon);
                    itemContent.appendChild(label);
                    
                    // Add the content container to the li element
                    li.appendChild(itemContent);
                    ul.appendChild(li);
                }
            });
        }
        
        // Handle file selection/deselection with limit enforcement (dedup-aware)
        function updateSelection(checkbox, skipMetricsUpdate = false) {
            const path = checkbox.dataset.path;
            const isFolder = checkbox.dataset.isFolder === 'true';

            if (!isFolder) {
                const file = fileMap.get(path);
                if (!file) {
                    if (checkbox.checked) checkbox.checked = false;
                    return;
                }

                if (checkbox.checked) {
                    // Enforce file count and size with cross-source deduplication
                    const { idsSet, count: currentCount, size: currentSize } = aggregateCurrentFilesDedup();
                    const isAlreadySelected = selectionOrder.includes(path);
                    const fileId = getDedupId(file);
                    const addsNewUnique = !idsSet.has(fileId) && !isAlreadySelected;
                    const potentialCount = currentCount + (addsNewUnique ? 1 : 0);
                    if (potentialCount > FILE_LIMITS.MAX_FILES) {
                        checkbox.checked = false;
                        showStatus(`Cannot select more files. Limit is ${FILE_LIMITS.MAX_FILES}.`, 'error');
                        return;
                    }

                    // Enforce total size (accumulated + selected + this) dedup-aware
                    const potentialSize = currentSize + (addsNewUnique ? (file.size || 0) : 0);
                    if (potentialSize > FILE_LIMITS.MAX_TOTAL_SIZE) {
                        const lim = (FILE_LIMITS.MAX_TOTAL_SIZE / 1024 / 1024).toFixed(0);
                        checkbox.checked = false;
                        showStatus(`Cannot select file. Total size would exceed ${lim}MB limit.`, 'error');
                        return;
                    }

                    if (!selectionOrder.includes(path)) selectionOrder.push(path);
                } else {
                    const index = selectionOrder.indexOf(path);
                    if (index > -1) selectionOrder.splice(index, 1);
                }
            }

            if (!skipMetricsUpdate) {
                updateMetricsPanelDebounced();
            }
        }
        
        // Utility: read a File as text and return a Promise
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = e => resolve(e.target && typeof e.target.result === 'string' ? e.target.result : '');
                reader.onerror = err => reject(err);
                reader.onabort = () => reject(new Error('Read cancelled'));
                const encodingSelect = document.getElementById('encodingSelect');
                const selectedEncoding = encodingSelect && encodingSelect.value ? encodingSelect.value : 'utf-8';
                // Many browsers alias Windows-1252 and ISO-8859-1; keep mapping for broad compatibility
                const actualEncoding = selectedEncoding === 'windows-1252' ? 'ISO-8859-1' : selectedEncoding;
                reader.readAsText(file, actualEncoding);
            });
        }

        let dropZone = document.getElementById('drop_zone');
        dropZone.addEventListener('drop', handleDrop, false);
        dropZone.addEventListener('dragover', handleDragOver, false);
        dropZone.addEventListener('dragleave', handleDragLeave, false);

        let copyButton = document.getElementById('copyButton');
        copyButton.addEventListener('click', async () => {
            await copyToClipboard();
        });
        
        let addFolderButton = document.getElementById('addFolderButton');
        addFolderButton.addEventListener('click', selectFolder);

        let clearButton = document.getElementById('clearButton');
        clearButton.addEventListener('click', clearAll);

        const hideToggle = document.getElementById('hideBinaryToggle');
        if (hideToggle) hideToggle.addEventListener('change', () => {
            if (!currentFolderFiles.length) return;
            const tree = buildFileTree(getFilteredFolderFiles());
            renderFileTree(tree);
        });

        // Persist encoding preference
        const encSel = document.getElementById('encodingSelect');
        if (encSel) {
            const savedEnc = localStorage.getItem('encoding');
            if (savedEnc && Array.from(encSel.options).some(o => o.value === savedEnc)) {
                encSel.value = savedEnc;
            }
            encSel.addEventListener('change', async () => {
                try { localStorage.setItem('encoding', encSel.value); } catch (_) {}

                // Clear cache when encoding changes to force re-reading files with new encoding
                fileContentCache.clear();

                // Re-render files if any are loaded
                const hasFiles = accumulatedFiles.size > 0 || selectionOrder.length > 0;
                if (hasFiles) {
                    await renderAllFiles();
                    showStatus('Files reloaded with new encoding', 'success');
                }
            });
        }

        // Clean up on page unload to prevent memory leaks
        window.addEventListener('beforeunload', () => {
            if (metricsUpdateTimer) {
                clearTimeout(metricsUpdateTimer);
                metricsUpdateTimer = null;
            }
            // Clear cache and references
            fileContentCache.clear();
            fileMap.clear();
            accumulatedFiles.clear();
        });
    </script>
</body>
</html>
